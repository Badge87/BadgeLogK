package com.danielebachicchi.badgelogk

import java.text.SimpleDateFormat
import java.time.format.DateTimeFormatter
import java.util.*

/**
 * Base class for all LogDestination. Subclass it for create a custom Log Destination.
 *
 * @author Daniele Bachicchi
 */
abstract class LogDestination {


    /**
     * Minimum [Logger.LogLevel] which this LogDestination will print the log row.
     * All levels under the minimum level will not be generated
     * ([LogDestination.send] will return an empty string).
     *
     * Default value is [Logger.LogLevel.VERBOSE].
     */
    protected var minLevel: Logger.LogLevel = Logger.LogLevel.VERBOSE

    /**
     * String format for every single rows generated by this [LogDestination].
     * Check out the documentation to know how to customize it
     */
    protected var format: String = "T '-' L '-' '['c':'l']' M e"
    /**
     * Date formatter for the log row.
     * */
    protected val dateFormatter: SimpleDateFormat =
        SimpleDateFormat("yyyy-MM-dd'T'HH:mm'Z'", Locale.US)

    /**
     * [LogLevelDescriptor] used inside this [LogDestination]
     */
    protected val logLevelDescriptor = LogLevelDescriptor()

    init {
        dateFormatter.timeZone = TimeZone.getTimeZone("UTC")
    }

    /**
     * Generate a formatted log row string according to [LogDestination.format].
     * Overwrite this method to save the log row generated.
     *
     * If [LogDestination.minLevel] is greater than [level] than the log row generated will be an
     * empty string.
     *
     * @param level the log level of this log row.
     * @param message the message of this log row.
     * @param error the throwable error (if present) of this log row.
     * @param tag the tag of this log row.
     * @param file the class name for this log row.
     * @param method the method name of this log row.
     * @param line the line number inside the [file] of this log row.
     *
     * @return the generated formatted log row string.
     * Empty if [LogDestination.minLevel] is greater than [level]
     */
     open fun send(
                            level: Logger.LogLevel,
                           message: String,
                           error: Throwable?,
                           tag: String,
                           file: String,
                           method: String,
                           line: Int): String {

         if (minLevel.ordinal > level.ordinal)
             return ""

         return formatMessage(format,
                                   level,
                                   message,
                                   error,
                                   tag,
                                   file,
                                   method,
                                   line)
    }

    private fun formatMessage(format: String,
                                level: Logger.LogLevel,
                                message: String,
                                error: Throwable?,
                                tag: String,
                                file: String,
                                method: String,
                                line: Int): String {
        val now = Date()
        var result = ""
        val formatVariables = format.chunked(1)
        var customString = false
        for (variable in formatVariables) {

            when {
                variable == "'" -> {
                    customString = !customString
                    continue
                }
                customString -> {
                    result += variable
                }
                else -> when(variable){
                    "M" -> result += message
                    "l" -> result += "$line"
                    "m" -> result += method
                    "f" -> result += file
                    "c" -> result += file.substring(file.lastIndexOf(".") + 1)
                    "t" -> result += tag
                    "e" -> result += if (error != null) "\n" + error.stackTraceToString() else ""
                    "L" -> result += logLevelDescriptor.describe(level)
                    "T" -> result += dateFormatter.format(now)
                    " " -> result += " "
                }
            }

        }
        return result
    }
}
/**
 * Data class for describing the various [Logger.LogLevel] inside this [LogDestination]
 * */
data class LogLevelDescriptor(var verbose: String = "VERBOSE",
                              var debug: String = "DEBUG",
                              var info: String = "INFO",
                              var warning: String = "WARNING",
                              var error: String = "ERROR") {
    /**
     * Return the description of the [Logger.LogLevel].
     *
     * @param level The level you want the description for.
     */
    fun describe(level: Logger.LogLevel): String {
        return when (level){
            Logger.LogLevel.VERBOSE -> verbose
            Logger.LogLevel.DEBUG -> debug
            Logger.LogLevel.INFO -> info
            Logger.LogLevel.WARNING -> warning
            Logger.LogLevel.ERROR -> error
        }
    }
}